---
title: 'Security & Monitoring'
description: 'NovaCloud EIP Security Layers and Server Monitoring'
icon: 'shield-check'
---

## üîê Security Architecture

NovaCloud implements multiple security layers to protect enterprise data:

```
Internet Traffic
    ‚Üì
DDoS Protection (iptables)
    ‚Üì
Firewall (UFW/iptables)
    ‚Üì
Rate Limiter (API Protection)
    ‚Üì
WAF (Web Application Firewall)
    ‚Üì
Next.js Application
    ‚Üì
Docker Network (Internal)
```

## Security Components

### 1. DDoS Protection

```bash
# iptables rules
sudo iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 80 -j DROP
```

### 2. Firewall (UFW)

```bash
# Enable UFW
sudo ufw enable

# Allow ports
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS
sudo ufw allow 3000/tcp  # Next.js (internal only)

# Block all others
sudo ufw default deny incoming
```

### 3. Rate Limiting

```bash
# Nginx rate limiting
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

location /api {
  limit_req zone=api burst=20 nodelay;
}
```

### 4. Web Application Firewall (WAF)

```bash
# ModSecurity rules
SecRule ARGS "@pm union select" \
  "id:1001,deny,status:403,msg:'SQL Injection'"

SecRule ARGS "@contains <script" \
  "id:1002,deny,status:403,msg:'XSS Attack'"
```

## Authentication & Authorization

### JWT Authentication

```typescript lib/auth.ts
import jwt from 'jsonwebtoken';

export function generateToken(userId: string) {
  return jwt.sign(
    { userId, iat: Date.now() },
    process.env.JWT_SECRET!,
    { expiresIn: '24h' }
  );
}

export function verifyToken(token: string) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET!);
  } catch {
    throw new Error('Invalid token');
  }
}
```

### Middleware

```typescript middleware/auth.ts
import { verifyToken } from '@/lib/auth';

export function withAuth(handler: any) {
  return async (req: any, res: any) => {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      if (!token) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      req.user = verifyToken(token);
      return handler(req, res);
    } catch (error) {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
}
```

## Data Encryption

### PostgreSQL Encrypted Columns

```sql
-- Install pgcrypto extension
CREATE EXTENSION pgcrypto;

-- Create encrypted column
ALTER TABLE customers ADD COLUMN ssn_encrypted bytea;

-- Encrypt data
UPDATE customers 
SET ssn_encrypted = pgp_sym_encrypt(ssn, 'encryption_key');

-- Decrypt data
SELECT pgp_sym_decrypt(ssn_encrypted, 'encryption_key') FROM customers;
```

### Environment Variables

```bash
# .env (NEVER commit this!)
ENCRYPTION_KEY=your_secure_key_here
JWT_SECRET=your_jwt_secret_here
DATABASE_PASSWORD=strong_password_here
```

## Row-Level Security (RLS)

```sql
-- Enable RLS
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

-- Create policy
CREATE POLICY customer_isolation ON customers
  USING (user_id = current_user_id());

-- Verify
SELECT * FROM customers; -- Only shows user's customers
```

## üìä Server Monitoring & Capacity

### Monitoring API

The Monitoring API (Container 1) collects metrics from all NovaCloud servers:

```typescript lib/monitoring.ts
export interface ServerMetrics {
  cpu_usage: number;        // 0-100%
  memory_usage: number;     // 0-100%
  disk_usage: number;       // 0-100%
  network_io: {
    bytes_in: number;
    bytes_out: number;
  };
  uptime: number;           // seconds
  timestamp: Date;
}

export async function getServerMetrics(serverId: string) {
  const metrics = await fetch(`http://monitoring:3001/metrics/${serverId}`);
  return metrics.json();
}
```

### Monitoring Endpoint

```typescript pages/api/monitoring/metrics.ts
import os from 'os';

export default function handler(req, res) {
  const cpuUsage = 100 - (os.freemem() / os.totalmem()) * 100;
  const uptime = os.uptime();

  res.json({
    cpu_usage: cpuUsage,
    memory_usage: (1 - os.freemem() / os.totalmem()) * 100,
    uptime,
    timestamp: new Date()
  });
}
```

### Dashboard Visualization

```typescript pages/monitoring.tsx
import { useEffect, useState } from 'react';
import { LineChart, Line, XAxis, YAxis } from 'recharts';

export default function MonitoringDashboard() {
  const [metrics, setMetrics] = useState<any[]>([]);

  useEffect(() => {
    const interval = setInterval(async () => {
      const data = await fetch('/api/monitoring/metrics').then(r => r.json());
      setMetrics(prev => [...prev, data].slice(-60)); // Keep last 60 samples
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>Server Monitoring</h1>
      <LineChart width={800} height={300} data={metrics}>
        <XAxis dataKey="timestamp" />
        <YAxis />
        <Line type="monotone" dataKey="cpu_usage" stroke="#FF9800" />
        <Line type="monotone" dataKey="memory_usage" stroke="#2196F3" />
      </LineChart>
    </div>
  );
}
```

## Alerts & Notifications

```typescript lib/alerts.ts
export async function checkThresholds(metrics: ServerMetrics) {
  const alerts = [];

  if (metrics.cpu_usage > 80) {
    alerts.push({
      level: 'warning',
      message: `High CPU usage: ${metrics.cpu_usage}%`
    });
  }

  if (metrics.memory_usage > 90) {
    alerts.push({
      level: 'critical',
      message: `Critical memory usage: ${metrics.memory_usage}%`
    });
  }

  if (metrics.disk_usage > 95) {
    alerts.push({
      level: 'critical',
      message: `Disk almost full: ${metrics.disk_usage}%`
    });
  }

  // Send notifications
  for (const alert of alerts) {
    await sendNotification(alert);
  }
}
```

## Backup & Disaster Recovery

```bash
# Database backup
pg_basebackup -D /backups/postgres_$(date +%Y%m%d) -Fp -P

# Restore from backup
pg_restore /backups/postgres_20240101/base/base.tar.gz

# Test recovery
psql --version && pg_restore --version
```

## Compliance & Audit

```sql
-- Audit logging
CREATE TABLE audit_log (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID,
  action VARCHAR(50),
  table_name VARCHAR(50),
  old_data JSONB,
  new_data JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Trigger for audit
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_log (user_id, action, table_name, new_data)
  VALUES (current_user_id(), TG_OP, TG_TABLE_NAME, to_jsonb(NEW));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER customers_audit
AFTER INSERT OR UPDATE ON customers
FOR EACH ROW EXECUTE FUNCTION audit_trigger();
```

## Next Steps

<CardGroup cols={2}>

<Card title="Architecture" icon="sitemap" href="/essentials/settings">
  System design overview
</Card>

<Card title="Containers" icon="cube" href="/essentials/code">
  Individual container configuration
</Card>

</CardGroup>
